import os

# Добавьте эту строку ПЕРЕД импортом PyQt5
os.environ[
    'QT_QPA_PLATFORM_PLUGIN_PATH'] = r'C:\Users\Владимир\AppData\Roaming\Python\Python312\site-packages\PyQt5\Qt5\plugins'

import sys
import numpy as np
import sympy as sp
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from mpl_toolkits.mplot3d import Axes3D
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from scipy import integrate
import time
import math


class IntegrationMethods:
    """Класс, реализующий различные методы численного интегрирования"""

    @staticmethod
    def left_rectangle(f, a, b, n):
        """Метод левых прямоугольников"""
        h = (b - a) / n
        x = a
        integral = 0
        for _ in range(n):
            fx = f(x)
            integral += fx * h
            x += h
        return integral

    @staticmethod
    def right_rectangle(f, a, b, n):
        """Метод правых прямоугольников"""
        h = (b - a) / n
        x = a + h
        integral = 0
        for _ in range(n):
            fx = f(x)
            integral += fx * h
            x += h
        return integral

    @staticmethod
    def middle_rectangle(f, a, b, n):
        """Метод средних прямоугольников"""
        h = (b - a) / n
        x = a + h / 2
        integral = 0
        for _ in range(n):
            fx = f(x)
            integral += fx * h
            x += h
        return integral

    @staticmethod
    def trapezoidal(f, a, b, n):
        """Метод трапеций"""
        h = (b - a) / n
        x = a
        integral = (f(a) + f(b)) * h / 2
        for i in range(1, n):
            x = a + i * h
            integral += f(x) * h
        return integral

    @staticmethod
    def simpson(f, a, b, n):
        """реализация Симпсона   ∫ f(x)dx ≈ h/3 * [(f(b) - f(a))/2 + Σ(f(a+ih) + 2f(a+ih+h/2)]"""
        h = (b - a) / n
        s = (f(b) - f(a)) / 2
        for i in range(n):
            s += f(a + i * h) + 2 * f(a + i * h + h / 2)
        return h / 3 * s


class ArcLengthCalculator:
    """Класс для ручного расчета длины дуги"""

    @staticmethod
    def calculate(f_sym, x_sym, a, b, n=1000):
        """
        Вычисление длины дуги кривой y = f(x) на интервале [a, b]

        Формула: L = ∫ₐᵇ √(1 + [f'(x)]²) dx
        """
        try:
            # Вычисляем производную функции
            f_prime_sym = sp.diff(f_sym, x_sym)

            # Создаем лямбда-функции для f(x) и f'(x)
            f_lambda = sp.lambdify(x_sym, f_sym, ['numpy', 'math'])
            f_prime_lambda = sp.lambdify(x_sym, f_prime_sym, ['numpy', 'math'])

            # Функция подынтегрального выражения: sqrt(1 + [f'(x)]^2)
            def integrand(x):
                try:
                    derivative = f_prime_lambda(x)
                    # Обработка комплексных чисел, если они возникают
                    if isinstance(derivative, complex):
                        derivative = derivative.real
                    return math.sqrt(1 + derivative ** 2)
                except Exception as e:
                    # Если произошла ошибка при вычислении, возвращаем 0
                    return 0

            # Вычисляем интеграл методом Симпсона (альтернативным)
            return IntegrationMethods.simpson(integrand, a, b, n)

        except Exception as e:
            print(f"Ошибка при вычислении длины дуги: {str(e)}")
            return None

    @staticmethod
    def calculate_surface_area(f_sym, x_sym, a, b, n=1000):
        """
        Вычисление площади поверхности вращения вокруг оси OX

        Формула: S = 2π ∫ₐᵇ |f(x)| √(1 + [f'(x)]²) dx
        """
        try:
            # Вычисляем производную функции
            f_prime_sym = sp.diff(f_sym, x_sym)

            # Создаем лямбда-функции
            f_lambda = sp.lambdify(x_sym, f_sym, ['numpy', 'math'])
            f_prime_lambda = sp.lambdify(x_sym, f_prime_sym, ['numpy', 'math'])

            # Функция подынтегрального выражения: 2π * |f(x)| * sqrt(1 + [f'(x)]^2)
            def integrand(x):
                try:
                    fx = f_lambda(x)
                    derivative = f_prime_lambda(x)

                    # Обработка комплексных чисел
                    if isinstance(fx, complex):
                        fx = fx.real
                    if isinstance(derivative, complex):
                        derivative = derivative.real

                    return 2 * math.pi * abs(fx) * math.sqrt(1 + derivative ** 2)
                except Exception as e:
                    return 0

            # Вычисляем интеграл методом Симпсона (альтернативным)
            return IntegrationMethods.simpson(integrand, a, b, n)

        except Exception as e:
            print(f"Ошибка при вычислении площади поверхности: {str(e)}")
            return None

    @staticmethod
    def calculate_volume(f_sym, x_sym, a, b, n=1000):
        """
        Вычисление объема тела вращения вокруг оси OX

        Формула: V = π ∫ₐᵇ [f(x)]² dx
        """
        try:
            # Создаем лямбда-функцию
            f_lambda = sp.lambdify(x_sym, f_sym, ['numpy', 'math'])

            # Функция подынтегрального выражения: π * [f(x)]^2
            def integrand(x):
                try:
                    fx = f_lambda(x)
                    # Обработка комплексных чисел
                    if isinstance(fx, complex):
                        fx = fx.real
                    return math.pi * fx ** 2
                except Exception as e:
                    return 0

            # Вычисляем интеграл методом Симпсона (альтернативным)
            return IntegrationMethods.simpson(integrand, a, b, n)

        except Exception as e:
            print(f"Ошибка при вычислении объема: {str(e)}")
            return None


class MathPlotCanvas(FigureCanvas):
    """Холст для построения графиков"""

    def __init__(self, parent=None, width=5, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)
        self.axes = self.fig.add_subplot(111)

    def plot_function(self, f, a, b, title="График функции"):
        """Построение графика функции и криволинейной трапеции"""
        self.axes.clear()

        # Основной график функции
        x_vals = np.linspace(a, b, 1000)
        y_vals = f(x_vals)
        self.axes.plot(x_vals, y_vals, 'b-', linewidth=2, label='f(x)')

        # Закрашиваем область под кривой
        self.axes.fill_between(x_vals, 0, y_vals, where=(y_vals > 0),
                               alpha=0.3, color='blue')
        self.axes.fill_between(x_vals, 0, y_vals, where=(y_vals < 0),
                               alpha=0.3, color='red')

        self.axes.axhline(y=0, color='k', linestyle='-', alpha=0.3)
        self.axes.axvline(x=a, color='k', linestyle='--', alpha=0.5)
        self.axes.axvline(x=b, color='k', linestyle='--', alpha=0.5)

        self.axes.set_xlabel('x')
        self.axes.set_ylabel('f(x)')
        self.axes.set_title(title)
        self.axes.legend()
        self.axes.grid(True, alpha=0.3)
        self.fig.tight_layout()
        self.draw()


class Surface3DCanvas(FigureCanvas):
    """Холст для построения 3D графиков"""

    def __init__(self, parent=None, width=5, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.fig)
        self.setParent(parent)
        self.axes = self.fig.add_subplot(111, projection='3d')

    def plot_surface_of_revolution(self, f, a, b, title="Поверхность вращения"):
        """Построение поверхности вращения вокруг оси OX"""
        self.axes.clear()

        # Создаем параметрическую сетку
        u = np.linspace(a, b, 100)  # ось x
        v = np.linspace(0, 2 * np.pi, 100)  # угол вращения

        U, V = np.meshgrid(u, v)

        # Вычисляем значения функции
        try:
            Y_values = f(U)

            # Параметрические уравнения поверхности вращения
            X = U
            Y = Y_values * np.cos(V)
            Z = Y_values * np.sin(V)

            # Построение поверхности С ЦВЕТОВОЙ КАРТОЙ, но БЕЗ ШКАЛЫ
            surf = self.axes.plot_surface(X, Y, Z, cmap='viridis',
                                          alpha=0.8, edgecolor='none',
                                          rstride=2, cstride=2)

            # Настройки графика
            self.axes.set_xlabel('X')
            self.axes.set_ylabel('Y')
            self.axes.set_zlabel('Z')
            self.axes.set_title(title)

            self.axes.view_init(elev=20, azim=45)

        except Exception as e:
            self.axes.text(0.5, 0.5, 0.5,
                           f"Не удалось построить 3D график",
                           transform=self.axes.transAxes,
                           ha='center', va='center')

        self.fig.tight_layout()
        self.draw()


class IntegrationGUI(QMainWindow):
    """Главное окно приложения"""

    def __init__(self):
        super().__init__()
        self.function_str = "3*x + log(x)"  # Первая функция по умолчанию
        self.a = 1  # Начало интервала
        self.b = 2  # Конец интервала
        self.init_ui()

    def init_ui(self):
        """Инициализация интерфейса"""
        self.setWindowTitle("Численное интегрирование")
        self.setGeometry(100, 100, 1400, 900)

        # Центральный виджет
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QHBoxLayout(central_widget)

        # Левая панель - управление
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)

        # Группа параметров функции
        group_func = QGroupBox("Параметры функции")
        form_layout = QFormLayout()

        self.func_combo = QComboBox()
        self.func_combo.addItems([
            "1. f(x) = 3x + ln(x) на [1, 2]",
            "2. f(x) = 1/(1 + x) на [0, 9]"
        ])
        self.func_combo.currentIndexChanged.connect(self.on_function_changed)
        form_layout.addRow("Функция:", self.func_combo)

        self.a_edit = QLineEdit("1")
        self.b_edit = QLineEdit("2")
        form_layout.addRow("a (начало):", self.a_edit)
        form_layout.addRow("b (конец):", self.b_edit)

        self.n_edit = QLineEdit("10")  # Только одно поле для n
        form_layout.addRow("n (разбиений):", self.n_edit)

        group_func.setLayout(form_layout)
        left_layout.addWidget(group_func)

        # Группа методов интегрирования
        group_methods = QGroupBox("Методы интегрирования")
        methods_layout = QVBoxLayout()

        self.methods_list = QListWidget()
        methods = [
            "Левые прямоугольники",
            "Правые прямоугольники",
            "Средние прямоугольники",
            "Метод трапеций",
            "Метод Симпсона (альтернативный)"
        ]
        for method in methods:
            self.methods_list.addItem(method)
        self.methods_list.setSelectionMode(QListWidget.MultiSelection)
        self.methods_list.selectAll()

        methods_layout.addWidget(self.methods_list)
        group_methods.setLayout(methods_layout)
        left_layout.addWidget(group_methods)

        # Кнопки
        btn_calculate = QPushButton("Вычислить")
        btn_calculate.clicked.connect(self.calculate)
        left_layout.addWidget(btn_calculate)

        btn_clear = QPushButton("Очистить")
        btn_clear.clicked.connect(self.clear_results)
        left_layout.addWidget(btn_clear)

        # Группа геометрических характеристик
        group_geo = QGroupBox("Геометрические характеристики (ручной расчет)")
        geo_layout = QVBoxLayout()

        self.geo_text = QTextEdit()
        self.geo_text.setReadOnly(True)
        self.geo_text.setMaximumHeight(150)
        geo_layout.addWidget(self.geo_text)

        group_geo.setLayout(geo_layout)
        left_layout.addWidget(group_geo)

        # Группа результатов
        group_results = QGroupBox("Результаты интегрирования")
        results_layout = QVBoxLayout()

        self.results_text = QTextEdit()
        self.results_text.setReadOnly(True)
        results_layout.addWidget(self.results_text)

        group_results.setLayout(results_layout)
        left_layout.addWidget(group_results)

        left_layout.addStretch()

        # Правая панель - графики
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)

        # 2D график
        self.plot_2d = MathPlotCanvas(self, width=6, height=4)
        right_layout.addWidget(self.plot_2d)

        # 3D график
        self.plot_3d = Surface3DCanvas(self, width=6, height=4)
        right_layout.addWidget(self.plot_3d)

        # Таблица результатов методов
        self.table_widget = QTableWidget()
        self.table_widget.setColumnCount(5)
        self.table_widget.setHorizontalHeaderLabels([
            "Метод", "n", "Значение интеграла", "Абс. погр.", "Отн. погр. (%)"
        ])
        right_layout.addWidget(self.table_widget)

        # Разделение панелей
        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setSizes([400, 1000])

        main_layout.addWidget(splitter)

        # Инициализация
        self.on_function_changed(0)

    def on_function_changed(self, index):
        """Обработка изменения выбранной функции"""
        if index == 0:  # 3*x + log(x)
            self.function_str = "3*x + log(x)"
            self.a_edit.setText("1")
            self.b_edit.setText("2")
        elif index == 1:  # 1/(1 + x)
            self.function_str = "1/(1 + x)"
            self.a_edit.setText("0")
            self.b_edit.setText("9")

        self.update_function(self.function_str)

    def update_function(self, func_str):
        """Обновление текущей функции"""
        self.function_str = func_str
        self.x_sym = sp.symbols('x')
        try:
            self.f_sym = sp.sympify(func_str)
            # Создаем безопасную функцию для numpy
            self.f_lambda = sp.lambdify(self.x_sym, self.f_sym, ['numpy', 'math'])
        except Exception as e:
            QMessageBox.warning(self, "Ошибка", f"Неверная функция: {str(e)}")
            self.function_str = "3*x + log(x)"
            self.f_sym = sp.sympify(self.function_str)
            self.f_lambda = sp.lambdify(self.x_sym, self.f_sym, ['numpy', 'math'])

    def format_number(self, num, precision=15, is_percent=False):
        """Форматирование числа"""
        if is_percent:
            # Для процентов показываем меньше знаков после запятой
            if num == 0:
                return "0.00%"
            elif abs(num) < 0.001:  # Меньше 0.001%
                return f"{num:.6f}%"
            elif abs(num) < 1:  # Меньше 1%
                return f"{num:.4f}%"
            else:
                return f"{num:.2f}%"

        if num == 0:
            return "0." + "0" * precision
        elif abs(num) < 1e-15:
            return f"{num:.{precision}f}"
        else:
            # Форматируем с фиксированной точкой
            formatted = f"{num:.{precision}f}"
            # Убираем лишние нули в конце
            if '.' in formatted:
                formatted = formatted.rstrip('0').rstrip('.')
            return formatted

    def calculate_geometric_properties(self, a, b):
        """Вычисление геометрических свойств с использованием ручного расчета"""
        geo_text = "=== ГЕОМЕТРИЧЕСКИЕ ХАРАКТЕРИСТИКИ ===\n"
        geo_text += "(расчет методом Симпсона (альтернативным) с n=1000)\n\n"

        try:
            # Вычисляем производную функции
            f_prime = sp.diff(self.f_sym, self.x_sym)
            derivative_str = sp.pretty(f_prime)
            geo_text += f"Производная f'(x) = {derivative_str}\n\n"

            # Длина дуги (ручной расчет)
            arc_length = ArcLengthCalculator.calculate(self.f_sym, self.x_sym, a, b)
            if arc_length is not None:
                geo_text += f"Длина дуги: {arc_length:.15f}\n"
                # Для сравнения покажем аналитическое значение, если возможно
                try:
                    # Пытаемся вычислить аналитически через sympy
                    arc_expr = sp.sqrt(1 + f_prime ** 2)
                    analytic_arc = sp.integrate(arc_expr, (self.x_sym, a, b))
                    if not analytic_arc.has(sp.Integral):
                        analytic_value = float(analytic_arc)
                        error = abs(arc_length - analytic_value)
                        geo_text += f"  (аналитически: {analytic_value:.15f}, погр.: {self.format_number(error)})\n"
                except:
                    pass
            else:
                geo_text += "Длина дуги: не удалось вычислить\n"

            geo_text += "\n"

            # Площадь поверхности вращения (ручной расчет)
            surface_area = ArcLengthCalculator.calculate_surface_area(self.f_sym, self.x_sym, a, b)
            if surface_area is not None:
                geo_text += f"Площадь пов. вращения: {surface_area:.15f}\n"
                # Для сравнения покажем аналитическое значение, если возможно
                try:
                    # Пытаемся вычислить аналитически через sympy
                    surface_expr = 2 * sp.pi * abs(self.f_sym) * sp.sqrt(1 + f_prime ** 2)
                    analytic_surface = sp.integrate(surface_expr, (self.x_sym, a, b))
                    if not analytic_surface.has(sp.Integral):
                        analytic_value = float(analytic_surface)
                        error = abs(surface_area - analytic_value)
                        geo_text += f"  (аналитически: {analytic_value:.15f}, погр.: {self.format_number(error)})\n"
                except:
                    pass
            else:
                geo_text += "Площадь пов. вращения: не удалось вычислить\n"

            geo_text += "\n"

            # Объем тела вращения (ручной расчет)
            volume = ArcLengthCalculator.calculate_volume(self.f_sym, self.x_sym, a, b)
            if volume is not None:
                geo_text += f"Объем тела вращения: {volume:.15f}\n"
                # Для сравнения покажем аналитическое значение, если возможно
                try:
                    # Пытаемся вычислить аналитически через sympy
                    volume_expr = sp.pi * self.f_sym ** 2
                    analytic_volume = sp.integrate(volume_expr, (self.x_sym, a, b))
                    if not analytic_volume.has(sp.Integral):
                        analytic_value = float(analytic_volume)
                        error = abs(volume - analytic_value)
                        geo_text += f"  (аналитически: {analytic_value:.15f}, погр.: {self.format_number(error)})\n"
                except:
                    pass
            else:
                geo_text += "Объем тела вращения: не удалось вычислить\n"

        except Exception as e:
            geo_text += f"Ошибка при вычислении геометрических характеристик:\n{str(e)}"

        self.geo_text.setText(geo_text)

    def calculate(self):
        """Вычисление интеграла различными методами"""
        try:
            # Получение параметров
            a = float(self.a_edit.text())
            b = float(self.b_edit.text())
            n = int(self.n_edit.text())  # Только одно значение n

            if a >= b:
                QMessageBox.warning(self, "Ошибка", "a должно быть меньше b")
                return

            self.a = a
            self.b = b

            # Вычисление геометрических свойств (ручной расчет)
            self.calculate_geometric_properties(a, b)

            # Точное значение интеграла через Sympy
            try:
                exact_integral_expr = sp.integrate(self.f_sym, (self.x_sym, a, b))
                if exact_integral_expr.has(sp.Integral):
                    # Если интеграл не может быть вычислен аналитически
                    exact_integral = None
                    exact_integral_str = "Не может быть вычислен аналитически"
                else:
                    exact_integral = float(exact_integral_expr)
                    exact_integral_str = f"{exact_integral:.15f}"
            except:
                exact_integral = None
                exact_integral_str = "Ошибка вычисления"

            # Сравнение с SciPy
            try:
                scipy_result, scipy_error = integrate.quad(self.f_lambda, a, b)
                scipy_success = True
            except:
                scipy_result = None
                scipy_error = None
                scipy_success = False

            # Вывод точных значений
            results = f"=== ИНФОРМАЦИЯ О ФУНКЦИИ ===\n"
            results += f"f(x) = {self.function_str}\n"
            results += f"Интервал: [{a}, {b}]\n"
            results += f"Количество разбиений: {n}\n\n"

            results += f"=== ТОЧНОЕ ЗНАЧЕНИЕ ИНТЕГРАЛА (SymPy) ===\n"
            results += f"Значение: {exact_integral_str}\n\n"

            if scipy_success:
                results += f"=== SciPy интеграл ===\n"
                results += f"Значение: {scipy_result:.15f}\n"
                results += f"Погрешность: {self.format_number(scipy_error)}\n\n"
            else:
                results += f"=== SciPy интеграл ===\n"
                results += f"Не удалось вычислить\n\n"

            self.results_text.setText(results)

            # Построение графиков
            self.plot_2d.plot_function(self.f_lambda, a, b,
                                       f"f(x) = {self.function_str}")

            # Построение 3D графика
            try:
                self.plot_3d.plot_surface_of_revolution(self.f_lambda, a, b,
                                                        f"Поверхность вращения f(x) = {self.function_str}")
            except Exception as e:
                self.plot_3d.axes.clear()
                self.plot_3d.axes.text(0.5, 0.5, 0.5,
                                       f"Не удалось построить 3D график",
                                       transform=self.plot_3d.axes.transAxes,
                                       ha='center', va='center')
                self.plot_3d.draw()

            # Вычисление численными методами
            if exact_integral is not None:
                self.calculate_numerical(exact_integral, a, b, n)
            else:
                self.calculate_numerical_no_exact(a, b, n)

        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при вычислениях:\n{str(e)}")

    def calculate_numerical(self, exact_value, a, b, n):
        """Вычисление численными методами с известным точным значением"""
        methods = {
            "Левые прямоугольники": IntegrationMethods.left_rectangle,
            "Правые прямоугольники": IntegrationMethods.right_rectangle,
            "Средние прямоугольники": IntegrationMethods.middle_rectangle,
            "Метод трапеций": IntegrationMethods.trapezoidal,
            "Метод Симпсона (альтернативный)": IntegrationMethods.simpson
        }

        selected_methods = [item.text() for item in self.methods_list.selectedItems()]
        data = []

        for method_name in selected_methods:
            if method_name in methods:
                method_func = methods[method_name]

                # Вычисление интеграла для заданного n
                result = method_func(self.f_lambda, a, b, n)
                abs_error = abs(result - exact_value)
                # Относительная погрешность в ПРОЦЕНТАХ
                rel_error = (abs_error / abs(exact_value) * 100) if exact_value != 0 else abs_error * 100

                data.append([
                    method_name,
                    n,
                    f"{result:.15f}",
                    self.format_number(abs_error),
                    self.format_number(rel_error, is_percent=True)
                ])

        # Добавляем точное значение для сравнения
        data.append([
            "Точное значение (SymPy)",
            "N/A",
            f"{exact_value:.15f}",
            self.format_number(0),
            self.format_number(0, is_percent=True)
        ])

        # Обновление таблицы
        self.table_widget.setRowCount(len(data))
        for i, row_data in enumerate(data):
            for j, value in enumerate(row_data):
                self.table_widget.setItem(i, j, QTableWidgetItem(str(value)))

        # Автонастройка ширины столбцов
        self.table_widget.resizeColumnsToContents()

    def calculate_numerical_no_exact(self, a, b, n):
        """Вычисление численными методами без точного значения"""
        methods = {
            "Левые прямоугольники": IntegrationMethods.left_rectangle,
            "Правые прямоугольники": IntegrationMethods.right_rectangle,
            "Средние прямоугольники": IntegrationMethods.middle_rectangle,
            "Метод трапеций": IntegrationMethods.trapezoidal,
            "Метод Симпсона (альтернативный)": IntegrationMethods.simpson
        }

        selected_methods = [item.text() for item in self.methods_list.selectedItems()]
        data = []

        # Используем SciPy как эталон, если доступно
        try:
            reference_result, _ = integrate.quad(self.f_lambda, a, b)
            reference_name = "SciPy (эталон)"
        except:
            # Если SciPy не работает, используем метод трапеций с большим n как эталон
            reference_n = 10000
            reference_result = IntegrationMethods.trapezoidal(self.f_lambda, a, b, reference_n)
            reference_name = f"Трапеции n={reference_n} (эталон)"

        for method_name in selected_methods:
            if method_name in methods:
                method_func = methods[method_name]

                # Вычисление интеграла для заданного n
                result = method_func(self.f_lambda, a, b, n)
                abs_error = abs(result - reference_result)
                # Относительная погрешность в ПРОЦЕНТАХ
                rel_error = (abs_error / abs(reference_result) * 100) if reference_result != 0 else abs_error * 100

                data.append([
                    method_name,
                    n,
                    f"{result:.15f}",
                    self.format_number(abs_error),
                    self.format_number(rel_error, is_percent=True)
                ])

        # Добавляем эталонное значение
        data.append([
            reference_name,
            "N/A",
            f"{reference_result:.15f}",
            self.format_number(0),
            self.format_number(0, is_percent=True)
        ])

        # Обновление таблицы
        self.table_widget.setRowCount(len(data))
        for i, row_data in enumerate(data):
            for j, value in enumerate(row_data):
                self.table_widget.setItem(i, j, QTableWidgetItem(str(value)))

        # Автонастройка ширины столбцов
        self.table_widget.resizeColumnsToContents()

    def clear_results(self):
        """Очистка результатов"""
        self.results_text.clear()
        self.geo_text.clear()
        self.table_widget.setRowCount(0)
        self.plot_2d.axes.clear()
        self.plot_3d.axes.clear()
        self.plot_2d.draw()
        self.plot_3d.draw()


def main():
    app = QApplication(sys.argv)
    app.setStyle('Fusion')  # Современный стиль

    # Светлая тема
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(240, 240, 240))
    palette.setColor(QPalette.WindowText, Qt.black)
    palette.setColor(QPalette.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.AlternateBase, QColor(245, 245, 245))
    palette.setColor(QPalette.ToolTipBase, QColor(255, 255, 220))
    palette.setColor(QPalette.ToolTipText, Qt.black)
    palette.setColor(QPalette.Text, Qt.black)
    palette.setColor(QPalette.Button, QColor(240, 240, 240))
    palette.setColor(QPalette.ButtonText, Qt.black)
    palette.setColor(QPalette.BrightText, Qt.red)
    palette.setColor(QPalette.Link, QColor(0, 100, 200))
    palette.setColor(QPalette.Highlight, QColor(0, 100, 200))
    palette.setColor(QPalette.HighlightedText, Qt.white)
    app.setPalette(palette)

    window = IntegrationGUI()
    window.show()
    sys.exit(app.exec_())


if __name__ == '__main__':
    main()
