import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import tkinter as tk
from tkinter import ttk, messagebox
from scipy.optimize import fsolve


class NonlinearSolverApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Решение систем нелинейных уравнений")
        self.root.geometry("1200x900")

        # Точность
        self.epsilon = 0.00001

        # Создание виджетов
        self.create_widgets()

    def create_widgets(self):
        # Фрейм выбора системы
        system_frame = ttk.LabelFrame(self.root, text="Выбор системы уравнений", padding=10)
        system_frame.grid(row=0, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

        self.system_var = tk.IntVar(value=1)

        ttk.Radiobutton(system_frame, text="Система 1: cos(x + 0,5) + y = 0,8 , sin(y) -2x =1,6",
                        variable=self.system_var, value=1).grid(row=0, column=0, sticky="w")
        ttk.Radiobutton(system_frame, text="Система 2: cos(x) + y = 1,2 , 2x - sin(y-0,5) = 2",
                        variable=self.system_var, value=2).grid(row=1, column=0, sticky="w")

        # Фрейм начального приближения
        init_frame = ttk.LabelFrame(self.root, text="Начальное приближение", padding=10)
        init_frame.grid(row=1, column=0, padx=10, pady=10, sticky="nsew")

        ttk.Label(init_frame, text="x0:").grid(row=0, column=0, padx=5)
        self.x0_entry = ttk.Entry(init_frame, width=15)
        self.x0_entry.grid(row=0, column=1, padx=5)
        self.x0_entry.insert(0, "0.5")

        ttk.Label(init_frame, text="y0:").grid(row=1, column=0, padx=5)
        self.y0_entry = ttk.Entry(init_frame, width=15)
        self.y0_entry.grid(row=1, column=1, padx=5)
        self.y0_entry.insert(0, "0.5")

        # Фрейм методов
        method_frame = ttk.LabelFrame(self.root, text="Методы решения", padding=10)
        method_frame.grid(row=1, column=1, padx=10, pady=10, sticky="nsew")

        self.method_var = tk.StringVar(value="Все методы")
        methods = ["Все методы", "Метод Ньютона", "Метод Зейделя", "Scipy fsolve"]

        for i, method in enumerate(methods):
            ttk.Radiobutton(method_frame, text=method,
                            variable=self.method_var, value=method).grid(row=i, column=0, sticky="w")

        # Кнопка решения
        solve_button = ttk.Button(self.root, text="Решить", command=self.solve_system)
        solve_button.grid(row=2, column=0, columnspan=2, pady=10)

        # Фрейм результатов
        results_frame = ttk.LabelFrame(self.root, text="Результаты", padding=10)
        results_frame.grid(row=3, column=0, columnspan=2, padx=10, pady=10, sticky="nsew")

        # Таблица результатов
        columns = ("Метод", "Итерации", "x", "y", "f1(x,y)", "f2(x,y)", "Время (с)")
        self.tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=10)

        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=100)

        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)

        self.tree.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

        # Фрейм проверки сходимости
        convergence_frame = ttk.LabelFrame(self.root, text="Проверка сходимости методом Зейделя", padding=10)
        convergence_frame.grid(row=4, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

        self.convergence_text = tk.Text(convergence_frame, height=12, wrap=tk.WORD, state=tk.DISABLED,
                                        font=("Courier New", 9))
        scrollbar_convergence = ttk.Scrollbar(convergence_frame, orient="vertical", command=self.convergence_text.yview)
        self.convergence_text.configure(yscrollcommand=scrollbar_convergence.set)
        self.convergence_text.grid(row=0, column=0, sticky="nsew")
        scrollbar_convergence.grid(row=0, column=1, sticky="ns")

        convergence_frame.grid_rowconfigure(0, weight=1)
        convergence_frame.grid_columnconfigure(0, weight=1)

        # Фрейм формул
        formulas_frame = ttk.LabelFrame(self.root, text="Формулы", padding=10)
        formulas_frame.grid(row=5, column=0, columnspan=2, padx=10, pady=10, sticky="ew")

        self.formulas_text = tk.Text(formulas_frame, height=8, wrap=tk.WORD, state=tk.DISABLED,
                                     font=("Courier New", 10))
        scrollbar_formulas = ttk.Scrollbar(formulas_frame, orient="vertical", command=self.formulas_text.yview)
        self.formulas_text.configure(yscrollcommand=scrollbar_formulas.set)
        self.formulas_text.grid(row=0, column=0, sticky="nsew")
        scrollbar_formulas.grid(row=0, column=1, sticky="ns")

        formulas_frame.grid_rowconfigure(0, weight=1)
        formulas_frame.grid_columnconfigure(0, weight=1)

        # График в декартовой системе координат
        self.fig, self.ax = plt.subplots(figsize=(8, 6))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().grid(row=0, column=2, rowspan=6, padx=10, pady=10, sticky="nsew")

        # Настройка весов строк и столбцов
        self.root.grid_rowconfigure(3, weight=1)
        self.root.grid_rowconfigure(4, weight=1)
        self.root.grid_rowconfigure(5, weight=0)
        self.root.grid_columnconfigure(2, weight=1)

        # Инициализация формул для системы по умолчанию
        self.update_formulas(1)

    def update_formulas(self, system_num):
        """Обновляет текст с формулами для выбранной системы"""
        self.formulas_text.config(state=tk.NORMAL)
        self.formulas_text.delete(1.0, tk.END)

        if system_num == 1:
            text = """СИСТЕМА УРАВНЕНИЙ:
1) cos(x + 0.5) + y = 0.8
2) sin(y) - 2x = 1.6

В КАНОНИЧЕСКОМ ВИДЕ:
1) f1(x,y) = cos(x + 0.5) + y - 0.8 = 0
2) f2(x,y) = sin(y) - 2x - 1.6 = 0

МАТРИЦА ЯКОБИ:
    [ -sin(x+0.5)     1   ]
J = [                     ]
    [    -2        cos(y) ]

МЕТОД НЬЮТОНА:
x_{k+1} = x_k - J^{-1}(x_k) * F(x_k)
где F(x) = [cos(x+0.5) + y - 0.8, sin(y) - 2x - 1.6]^T

МЕТОД ЗЕЙДЕЛЯ:
x_{k+1} = (sin(y_k) - 1.6) / 2
y_{k+1} = 0.8 - cos(x_{k+1} + 0.5)
"""
        else:
            text = """СИСТЕМА УРАВНЕНИЙ:
1) cos(x) + y = 1.2
2) 2x - sin(y-0.5) = 2

В КАНОНИЧЕСКОМ ВИДЕ:
1) f1(x,y) = cos(x) + y - 1.2 = 0
2) f2(x,y) = 2x - sin(y-0.5) - 2 = 0

МАТРИЦА ЯКОБИ:
    [ -sin(x)       1       ]
J = [                       ]
    [    2      -cos(y-0.5) ]

МЕТОД НЬЮТОНА:
x_{k+1} = x_k - J^{-1}(x_k) * F(x_k)
где F(x) = [cos(x) + y - 1.2, 2x - sin(y-0.5) - 2]^T

МЕТОД ЗЕЙДЕЛЯ:
x_{k+1} = (2 + sin(y_k - 0.5)) / 2
y_{k+1} = 1.2 - cos(x_{k+1})
"""

        self.formulas_text.insert(1.0, text)
        self.formulas_text.config(state=tk.DISABLED)

    def get_system(self, system_num):
        """Возвращает функции системы уравнений"""
        if system_num == 1:
            # Система 1: cos(x + 0,5) + y = 0,8 , sin(y) -2x =1,6
            def f1(x, y):
                return np.cos(x + 0.5) + y - 0.8

            def f2(x, y):
                return np.sin(y) - 2 * x - 1.6

            def F(X):
                x, y = X
                return [f1(x, y), f2(x, y)]

            # Якобиан для системы 1
            def J(X):
                x, y = X
                return [[-np.sin(x + 0.5), 1],
                        [-2, np.cos(y)]]

            # Функции для метода Зейделя
            def phi1(x, y):
                # Из f2: x = (sin(y) - 1.6) / 2
                return (np.sin(y) - 1.6) / 2

            def phi2(x, y):
                # Из f1: y = 0.8 - cos(x + 0.5)
                return 0.8 - np.cos(x + 0.5)

            return F, J, f1, f2, phi1, phi2

        else:
            # Система 2: cos(x) + y = 1,2 , 2x - sin(y-0,5) = 2
            def f1(x, y):
                return np.cos(x) + y - 1.2

            def f2(x, y):
                return 2 * x - np.sin(y - 0.5) - 2

            def F(X):
                x, y = X
                return [f1(x, y), f2(x, y)]

            # Якобиан для системы 2
            def J(X):
                x, y = X
                return [[-np.sin(x), 1],
                        [2, -np.cos(y - 0.5)]]

            # Функции для метода Зейделя
            def phi1(x, y):
                # Из f2: x = (2 + sin(y - 0.5)) / 2
                return (2 + np.sin(y - 0.5)) / 2

            def phi2(x, y):
                # Из f1: y = 1.2 - cos(x)
                return 1.2 - np.cos(x)

            return F, J, f1, f2, phi1, phi2

    def compute_deltas(self, x_new, y_new, x_old, y_old):
        """Вычисляет дельты двумя способами"""
        # Способ 1: максимальное абсолютное значение
        delta_max = max(abs(x_new - x_old), abs(y_new - y_old))

        # Способ 2: среднее арифметическое абсолютных разностей
        delta_avg = (abs(x_new - x_old) + abs(y_new - y_old)) / 2

        return delta_max, delta_avg

    def newton_method(self, F, J, x0, y0, max_iter=1000):
        """Метод Ньютона для системы уравнений"""
        X = np.array([x0, y0], dtype=float)
        X_prev = X.copy()
        iterations = 0
        history = []

        for i in range(max_iter):
            FX = np.array(F(X))
            JX = np.array(J(X))

            # Проверка на вырожденность матрицы
            if np.linalg.det(JX) == 0:
                return None, None, history

            # Решение линейной системы J*dX = -F
            dX = np.linalg.solve(JX, -FX)
            X = X + dX

            iterations += 1

            # Вычисляем дельты двумя способами
            delta_max, delta_avg = self.compute_deltas(X[0], X[1], X_prev[0], X_prev[1])

            history.append((iterations, X[0], X[1], delta_max, delta_avg, FX[0], FX[1]))

            # Проверка сходимости по обоим критериям
            if (np.linalg.norm(FX) < self.epsilon and
                    delta_max < self.epsilon and
                    delta_avg < self.epsilon):
                break

            # Сохраняем текущее значение для следующей итерации
            X_prev = X.copy()

        return X, iterations, history

    def seidel_method(self, phi1, phi2, f1, f2, x0, y0, max_iter=1000):
        """Метод Зейделя для решения системы уравнений"""
        x, y = x0, y0
        iterations = 0
        history = []

        for i in range(max_iter):
            # Метод Зейделя: используем уже обновленные значения
            x_new = phi1(x, y)
            y_new = phi2(x, y)

            iterations += 1

            # Вычисляем дельты
            delta_max, delta_avg = self.compute_deltas(x_new, y_new, x, y)

            # Вычисляем невязки
            fx = f1(x_new, y_new)
            fy = f2(x_new, y_new)

            history.append((iterations, x_new, y_new, delta_max, delta_avg, fx, fy))

            # Проверка сходимости по обоим критериям
            if delta_max < self.epsilon and delta_avg < self.epsilon:
                x, y = x_new, y_new
                break

            x, y = x_new, y_new

        return np.array([x, y]), iterations, history

    def check_convergence_around_root(self, phi1, phi2, root, h=0.01):
        """Проверка сходимости метода Зейделя вокруг корня"""
        if root is None:
            return ""

        x_root, y_root = root[0], root[1]

        # Точки вокруг корня
        points = [
            [x_root, y_root],  # Точка 0: сам корень
            [x_root - h, y_root],  # Точка 1: слева
            [x_root + h, y_root],  # Точка 2: справа
            [x_root, y_root - h],  # Точка 3: снизу
            [x_root, y_root + h],  # Точка 4: сверху
            [x_root - h, y_root - h],  # Точка 5: слева снизу
            [x_root + h, y_root - h],  # Точка 6: справа снизу
            [x_root - h, y_root + h],  # Точка 7: слева сверху
            [x_root + h, y_root + h]  # Точка 8: справа сверху
        ]

        result = "=" * 60 + "\n"
        result += "ПРОВЕРКА СХОДИМОСТИ МЕТОДА ЗЕЙДЕЛЯ ВОКРУГ КОРНЯ\n"
        result += "=" * 60 + "\n\n"

        result += f"Корень: [{x_root:.6f}, {y_root:.6f}]\n\n"

        for i, (x, y) in enumerate(points):
            # Вычисляем частные производные
            eps = 1e-6

            # Производные phi1
            dphi1_dx = (phi1(x + eps, y) - phi1(x, y)) / eps
            dphi1_dy = (phi1(x, y + eps) - phi1(x, y)) / eps

            # Производные phi2 (для метода Зейделя: phi2 зависит от phi1(x,y))
            phi1_val = phi1(x, y)
            dphi2_dphi1 = (phi2(phi1_val + eps, y) - phi2(phi1_val, y)) / eps
            dphi2_dx = dphi2_dphi1 * dphi1_dx
            dphi2_dy = dphi2_dphi1 * dphi1_dy + (phi2(phi1_val, y + eps) - phi2(phi1_val, y)) / eps

            # Вычисляем суммы модулей производных для каждого уравнения
            sum1 = abs(dphi1_dx) + abs(dphi1_dy)
            sum2 = abs(dphi2_dx) + abs(dphi2_dy)

            # Максимальная сумма
            max_sum = max(sum1, sum2)

            # Определяем условие сходимости
            converged = max_sum < 1

            if i == 0:
                result += f"Точка (корень): [{x:.6f}, {y:.6f}]\n"
            else:
                result += f"Точка {i}: [{x:.6f}, {y:.6f}]\n"

            # Выводим матрицу Якоби преобразования φ
            result += f"  Матрица Якоби преобразования φ:\n"
            result += f"  [ {dphi1_dx:10.6f}  {dphi1_dy:10.6f} ]\n"
            result += f"  [ {dphi2_dx:10.6f}  {dphi2_dy:10.6f} ]\n"

            result += f"  Уравнение 1: Σ|∂φ1/∂x_j| = {sum1:.6f}\n"
            result += f"  Уравнение 2: Σ|∂φ2/∂x_j| = {sum2:.6f}\n"
            result += f"  Максимум: {max_sum:.6f} "
            result += "✓ Условие сходимости выполняется\n" if converged else "✗ Условие сходимости не выполняется\n"

            # Для точек вокруг корня добавляем дополнительную информацию
            if i > 0:
                distance = np.sqrt((x - x_root) ** 2 + (y - y_root) ** 2)
                result += f"  Расстояние до корня: {distance:.6f}\n"

            result += "\n"

        return result

    def check_seidel_convergence(self, phi1, phi2, x0, y0):
        """Проверка условия сходимости метода Зейделя"""
        # Производные функций phi
        h = 1e-6

        # Для метода Зейделя учитываем, что phi2 зависит от x_new
        # dphi1/dx и dphi1/dy такие же
        dphi1_dx = (phi1(x0 + h, y0) - phi1(x0, y0)) / h
        dphi1_dy = (phi1(x0, y0 + h) - phi1(x0, y0)) / h

        # Для phi2: y = phi2(x_new, y_old) = phi2(phi1(x_old, y_old), y_old)
        # Нужно учесть цепное правило
        # dphi2/dx = dphi2/d(phi1) * dphi1/dx
        # dphi2/dy = dphi2/d(phi1) * dphi1/dy + dphi2/dy

        # Вычисляем производные phi2 по первому аргументу
        phi1_val = phi1(x0, y0)
        dphi2_dphi1 = (phi2(phi1_val + h, y0) - phi2(phi1_val, y0)) / h

        dphi2_dx = dphi2_dphi1 * dphi1_dx
        dphi2_dy = dphi2_dphi1 * dphi1_dy + (phi2(phi1_val, y0 + h) - phi2(phi1_val, y0)) / h

        # Матрица Якоби для phi
        J_phi = np.array([[dphi1_dx, dphi1_dy],
                          [dphi2_dx, dphi2_dy]])

        # Проверка условия сходимости: норма матрицы Якоби < 1
        norm1 = np.linalg.norm(J_phi, 1)  # 1-норма
        norm2 = np.linalg.norm(J_phi, 2)  # 2-норма (спектральная)
        norm_inf = np.linalg.norm(J_phi, np.inf)  # ∞-норма

        # Вычисление собственных значений
        eigenvalues = np.linalg.eigvals(J_phi)
        spectral_radius = np.max(np.abs(eigenvalues))

        return norm1, norm2, norm_inf, spectral_radius, J_phi

    def plot_system(self, f1, f2, solutions=None):
        """Построение графика системы уравнений в декартовой системе"""
        self.ax.clear()

        # Создание сетки
        x = np.linspace(-3, 3, 400)
        y = np.linspace(-3, 3, 400)
        X, Y = np.meshgrid(x, y)

        # Вычисление функций
        Z1 = f1(X, Y)
        Z2 = f2(X, Y)

        # Линии уровня для f1(x,y)=0
        contour1 = self.ax.contour(X, Y, Z1, levels=[0], colors='red', linewidths=2)

        # Линии уровня для f2(x,y)=0
        contour2 = self.ax.contour(X, Y, Z2, levels=[0], colors='blue', linewidths=2, linestyles='--')

        # Заполнение областей для визуализации знаков функций
        self.ax.contourf(X, Y, Z1, levels=[-100, 0, 100], colors=['lightcoral', 'lightblue'], alpha=0.3)
        self.ax.contourf(X, Y, Z2, levels=[-100, 0, 100], colors=['lightpink', 'lightcyan'], alpha=0.3)

        # Отображение решений
        if solutions:
            for i, sol in enumerate(solutions):
                if sol is not None:
                    self.ax.plot(sol[0], sol[1], 'go', markersize=12, markeredgecolor='black',
                                 markeredgewidth=2, label=f'Решение {i + 1}: ({sol[0]:.4f}, {sol[1]:.4f})')

        # Отображение начального приближения
        try:
            x0 = float(self.x0_entry.get())
            y0 = float(self.y0_entry.get())
            self.ax.plot(x0, y0, 'm*', markersize=15, markeredgecolor='black',
                         markeredgewidth=2, label=f'Начальное приближение: ({x0:.2f}, {y0:.2f})')
        except:
            pass

        self.ax.set_xlabel('x', fontsize=12)
        self.ax.set_ylabel('y', fontsize=12)

        # Выбор заголовка в зависимости от системы
        if self.system_var.get() == 1:
            title = r'$\cos(x + 0.5) + y = 0.8$' + '\n' + r'$\sin(y) - 2x = 1.6$'
        else:
            title = r'$\cos(x) + y = 1.2$' + '\n' + r'$2x - \sin(y-0.5) = 2$'
        self.ax.set_title(title, fontsize=14, fontweight='bold')

        # Легенда
        from matplotlib.lines import Line2D
        if self.system_var.get() == 1:
            label1 = r'$\cos(x+0.5) + y - 0.8 = 0$'
            label2 = r'$\sin(y) - 2x - 1.6 = 0$'
        else:
            label1 = r'$\cos(x) + y - 1.2 = 0$'
            label2 = r'$2x - \sin(y-0.5) - 2 = 0$'

        legend_elements = [
            Line2D([0], [0], color='red', lw=2, label=label1),
            Line2D([0], [0], color='blue', lw=2, linestyle='--', label=label2),
        ]
        if solutions:
            legend_elements.append(Line2D([0], [0], marker='o', color='w',
                                          markerfacecolor='green', markeredgecolor='black',
                                          markersize=10, label='Найденные решения'))

        try:
            x0 = float(self.x0_entry.get())
            y0 = float(self.y0_entry.get())
            legend_elements.append(Line2D([0], [0], marker='*', color='w',
                                          markerfacecolor='magenta', markeredgecolor='black',
                                          markersize=10, label='Начальное приближение'))
        except:
            pass

        self.ax.legend(handles=legend_elements, loc='upper right', fontsize=10)

        self.ax.grid(True, alpha=0.3)
        self.ax.axhline(y=0, color='k', linestyle='-', linewidth=0.5)
        self.ax.axvline(x=0, color='k', linestyle='-', linewidth=0.5)

        # Установим одинаковый масштаб по осям
        self.ax.set_aspect('equal', adjustable='box')

        # Установим пределы осей
        self.ax.set_xlim([-2, 2])
        self.ax.set_ylim([-2, 2])

        self.fig.tight_layout()
        self.canvas.draw()

    def solve_system(self):
        """Основная функция решения системы"""
        try:
            # Очистка таблицы
            for item in self.tree.get_children():
                self.tree.delete(item)

            # Очистка текста проверки сходимости
            self.convergence_text.config(state=tk.NORMAL)
            self.convergence_text.delete(1.0, tk.END)
            self.convergence_text.config(state=tk.DISABLED)

            # Получение параметров
            system_num = self.system_var.get()
            method = self.method_var.get()
            x0 = float(self.x0_entry.get())
            y0 = float(self.y0_entry.get())

            # Обновление формул
            self.update_formulas(system_num)

            # Получение системы уравнений
            F, J, f1, f2, phi1, phi2 = self.get_system(system_num)

            solutions = []
            all_methods = []

            # Выполнение выбранных методов
            import time

            # ВЫВОД МАТРИЦЫ ЯКОБИ ИСХОДНОЙ СИСТЕМЫ
            jacobian_matrix = J([x0, y0])
            jacobian_info = "=" * 60 + "\n"
            jacobian_info += "МАТРИЦА ЯКОБИ ИСХОДНОЙ СИСТЕМЫ В НАЧАЛЬНОЙ ТОЧКЕ\n"
            jacobian_info += "=" * 60 + "\n\n"
            jacobian_info += f"Начальная точка: [{x0:.6f}, {y0:.6f}]\n\n"

            if system_num == 1:
                jacobian_info += "Для системы 1:\n"
                jacobian_info += f"J(x,y) = [ [-sin(x+0.5), 1], [-2, cos(y)] ]\n"
            else:
                jacobian_info += "Для системы 2:\n"
                jacobian_info += f"J(x,y) = [ [-sin(x), 1], [2, -cos(y-0.5)] ]\n"

            jacobian_info += f"\nВычисленная матрица Якоби:\n"
            jacobian_info += f"  [ {jacobian_matrix[0][0]:10.6f}  {jacobian_matrix[0][1]:10.6f} ]\n"
            jacobian_info += f"  [ {jacobian_matrix[1][0]:10.6f}  {jacobian_matrix[1][1]:10.6f} ]\n\n"

            # Вычисляем определитель матрицы Якоби
            det_jacobian = np.linalg.det(jacobian_matrix)
            jacobian_info += f"Определитель матрицы Якоби: {det_jacobian:.6f}\n"

            if abs(det_jacobian) < 1e-10:
                jacobian_info += "⚠️ Матрица Якоби близка к вырожденной!\n"
            else:
                jacobian_info += "✓ Матрица Якоби невырожденная\n"

            jacobian_info += "\n" + "=" * 60 + "\n\n"

            if method in ["Все методы", "Метод Ньютона"]:
                start_time = time.time()
                solution, iterations, history = self.newton_method(F, J, x0, y0)
                elapsed_time = time.time() - start_time

                if solution is not None:
                    solutions.append(solution)
                    fx, fy = F(solution)
                    self.tree.insert("", "end", values=("Ньютон", iterations,
                                                        f"{solution[0]:.10f}", f"{solution[1]:.10f}",
                                                        f"{fx:.10f}", f"{fy:.10f}",
                                                        f"{elapsed_time:.10f}"))
                    all_methods.append(("Метод Ньютона", history))

            if method in ["Все методы", "Метод Зейделя"]:
                # Проверка сходимости
                norm1, norm2, norm_inf, spectral_radius, J_phi = self.check_seidel_convergence(
                    phi1, phi2, x0, y0)

                # Сохраняем первое решение для проверки сходимости вокруг корня
                first_solution = None

                start_time = time.time()
                solution, iterations, history = self.seidel_method(
                    phi1, phi2, f1, f2, x0, y0)
                elapsed_time = time.time() - start_time

                if solution is not None:
                    solutions.append(solution)
                    first_solution = solution  # Сохраняем для проверки сходимости
                    fx, fy = F(solution)
                    self.tree.insert("", "end", values=("Зейдель", iterations,
                                                        f"{solution[0]:.8f}", f"{solution[1]:.10f}",
                                                        f"{fx:.10f}", f"{fy:.10f}",
                                                        f"{elapsed_time:.10f}"))
                    all_methods.append(("Метод Зейделя", history))

                # Проверка сходимости вокруг корня (если решение найдено)
                if first_solution is not None:
                    convergence_info = self.check_convergence_around_root(phi1, phi2, first_solution)

                    # Добавляем информацию о начальной точке
                    self.convergence_text.config(state=tk.NORMAL)
                    self.convergence_text.delete(1.0, tk.END)

                    # Сначала выводим информацию о матрице Якоби
                    self.convergence_text.insert(1.0, jacobian_info)

                    # Затем информацию о сходимости метода Зейделя
                    header = "=" * 60 + "\n"
                    header += "ПРОВЕРКА СХОДИМОСТИ МЕТОДА ЗЕЙДЕЛЯ\n"
                    header += "=" * 60 + "\n\n"

                    header += f"Начальное приближение: [{x0:.6f}, {y0:.6f}]\n"
                    header += f"Найденный корень: [{first_solution[0]:.6f}, {first_solution[1]:.6f}]\n\n"

                    # Добавляем информацию о нормах матрицы Якоби преобразования
                    header += "МАТРИЦА ЯКОБИ ПРЕОБРАЗОВАНИЯ φ:\n"
                    header += f"  [ {J_phi[0][0]:10.6f}  {J_phi[0][1]:10.6f} ]\n"
                    header += f"  [ {J_phi[1][0]:10.6f}  {J_phi[1][1]:10.6f} ]\n\n"

                    header += f"Нормы матрицы Якоби преобразования:\n"
                    header += f"  1-норма: {norm1:.6f} "
                    header += "✓ < 1\n" if norm1 < 1 else "✗ ≥ 1\n"
                    header += f"  2-норма (спектральная): {norm2:.6f} "
                    header += "✓ < 1\n" if norm2 < 1 else "✗ ≥ 1\n"
                    header += f"  ∞-норма: {norm_inf:.6f} "
                    header += "✓ < 1\n" if norm_inf < 1 else "✗ ≥ 1\n"
                    header += f"  Спектральный радиус: {spectral_radius:.6f} "
                    header += "✓ < 1\n" if spectral_radius < 1 else "✗ ≥ 1\n\n"

                    self.convergence_text.insert(tk.END, header + convergence_info)
                    self.convergence_text.config(state=tk.DISABLED)

            if method in ["Все методы", "Scipy fsolve"]:
                start_time = time.time()
                solution = fsolve(F, [x0, y0], xtol=self.epsilon)
                elapsed_time = time.time() - start_time

                if solution is not None:
                    solutions.append(solution)
                    fx, fy = F(solution)
                    self.tree.insert("", "end", values=("Scipy fsolve", "-",
                                                        f"{solution[0]:.10f}", f"{solution[1]:.10f}",
                                                        f"{fx:.10f}", f"{fy:.10f}",
                                                        f"{elapsed_time:.10f}"))

            # Построение графика
            self.plot_system(f1, f2, solutions)

            # Вывод истории итераций
            if all_methods and method != "Scipy fsolve":
                self.show_iteration_history(all_methods)

        except Exception as e:
            messagebox.showerror("Ошибка", f"Произошла ошибка: {str(e)}")

    def show_iteration_history(self, all_methods):
        """Отображение истории итераций"""
        history_window = tk.Toplevel(self.root)
        history_window.title("История итераций")
        history_window.geometry("1000x400")

        # Создание Notebook для вкладок
        notebook = ttk.Notebook(history_window)

        for method_name, history in all_methods:
            frame = ttk.Frame(notebook)
            notebook.add(frame, text=method_name)

            # Создание Treeview для истории
            columns = ("Итерация", "x", "y", "Δmax", "avg", "f1(x,y)", "f2(x,y)")

            tree = ttk.Treeview(frame, columns=columns, show="headings", height=15)

            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=100)

            scrollbar = ttk.Scrollbar(frame, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)

            tree.grid(row=0, column=0, sticky="nsew")
            scrollbar.grid(row=0, column=1, sticky="ns")

            # Заполнение данными
            for iter_data in history:
                iter_num, x, y, delta_max, delta_avg, fx, fy = iter_data
                tree.insert("", "end", values=(iter_num, f"{x:.15f}", f"{y:.15f}",
                                               f"{delta_max:.15f}", f"{delta_avg:.15f}",
                                               f"{fx:.15f}", f"{fy:.15f}"))

            frame.grid_rowconfigure(0, weight=1)
            frame.grid_columnconfigure(0, weight=1)

        notebook.pack(expand=True, fill="both", padx=10, pady=10)


def main():
    root = tk.Tk()
    app = NonlinearSolverApp(root)
    root.mainloop()


if __name__ == "__main__":
    main()
